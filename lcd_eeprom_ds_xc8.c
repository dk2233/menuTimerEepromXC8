


//WDTE_OFF & PWRTE_OFF & BOREN_OFF & LVP_OFF & WRT_OFF & DEBUG_ON & CPD_OFF & CP_OFF)

/*


	dodano tu zapisywanie zmiennej do eeprom

	
	
	dodano obsluge komunikacji z ds18b20

*/

//xc8
#include <xc.h>
#include "lcd_eeprom_ds_xc8.h"
// #include "../libs/eeprom.h"
//sdcc
//#include <pic18fregs.h>
#include <stdlib.h>
#include <Lcd_hd44780_xc8.h>
#include <eeprom_xc8.h>
#include <ds18b20_xc8.h>
#include <stdio.h>
// Lcd_hd44780.c
// #include <delay.h>
// #include <delay.h>

// #include <math.h>



// FUSES START
// Minimum modifications needed. Rest of fuses left as default.

//The code generated by SDCC does probably not work when XINST (extended instruction set) is enabled
#pragma config RETEN = OFF  //
#pragma config SOSCSEL = DIG  //  
#pragma config XINST=OFF
#pragma config FOSC = HS1     // XT do 4MHZ
#pragma config PLLCFG = OFF 
#pragma config FCMEN = OFF 
#pragma config IESO = OFF  //  
#pragma config PWRTEN = ON  //
#pragma config BOREN = OFF
// Watchdog timer OFF
#pragma config WDTEN = OFF
// Single-Supply ICSP OFF
#pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
#pragma config CANMX = PORTB
#pragma config STVREN = ON  //    
#pragma config MSSPMSK = MSK7  //  




 
//__data __at (0x020b) unsigned int tab[4];

 // __data __at (0x0202) unsigned char i;
unsigned char tab_ds[jak_duzo_bajtow_odbieram] ;
unsigned char i;
unsigned char tab_ok[4] = {'o','k',0};
unsigned char tab_crc_ok[7] = "crc ok";
unsigned char tab_pomiar[3] = {0xcc,0x44,0x00};
unsigned char tab_odczyt[3] = {0xcc,0xbe,0x00};
// unsigned char tab_test[2] = {0x55,0x00};
unsigned char ile_czasu_wcisnieto = 0;

unsigned char tab[4];

struct linie_menu { 
	char *linia;
	unsigned char zmienna;
	unsigned char location;		
};	
	
struct linie_menu menu[] = {
		{(void *)" ", 0, 2 },
		{(void *)"ds:",0, 4},
		{(unsigned char *)"t:",0,3},
		{(unsigned char *)"sekundy", 0, 9},
		{(unsigned char *)"minuty", 50, 9},
		{(unsigned char *)"godziny", 24, 8},
		{(unsigned char *)"zapisz",0, 10},
		{(unsigned char *)" ",0,1},
		{(unsigned char *)" ",0,1},
		{(unsigned char *)" ",0,2},
		{(unsigned char *)"znak",0,7},
		{(unsigned char *)"crc",0,5}
	};

//definicja  markerow	
typedef struct 
{
  unsigned bit0  : 1;
  unsigned bit1  : 1;
  unsigned bit2  : 1;
  unsigned bit3  : 1;
  unsigned bit4  : 1;
  unsigned bit5  : 1;
  unsigned bit6  : 1;
  unsigned bit7  : 1;
} znaczniki_var;	


struct lcd_opcje ustawienia_lcd={ 4, 2, 0,0,0 }; 	
// znaczniki_var	*markers1;	
// znaczniki_var	*markers2;	
unsigned int	markers1;


	
// void napisz(unsigned char * tab);
// unsigned int show_menu(unsigned int nr);
// unsigned int show_menu(unsigned int nr, znaczniki_var * markers1);
unsigned int show_menu(unsigned int nr, unsigned int markers1);
void   sprawdz_opcje(unsigned int nr, unsigned int adres_linii);
void wyswietl_czas(void);
void sprawdz_przekroczenie(struct linie_menu mm[]);






void InterruptsEnable(void)
{
	INTCON1= 0 ;
	INTCONbits.PEIE = 1;
	INTCONbits.GIE = 1;
	INTCONbits.TMR0IE = 1; //enable Interrupt 0 (RB0 as interrupt)
	RCONbits.IPEN=0; 
	
	
	//prescaler    16
	//to daje 1 s na przerwanie
	T0CON = 0b10000011;
	PIE1bits.TMR1IE = 0;	

} 




void deklaracje(void) {	
	INTCON = 0;
	INTCON2 = 0;
	INTCON3 = 0;
	WREG =0;
	ANCON0 = WREG;
	ANCON1 = WREG;
	ADCON0 = 0 ;
	ADCON1 = 0 ;	    
	TRISE = 0b00000111;		
	tris_lcd = 0b11000000;
	TRISD = 0xff;
	TRISDbits.TRISD4 = 0; 
	LED_TRIS = 0; // Pin as output
	TRISB = 0xff ;
	TRISA = 0xff; 
	PORTA = 0;
	PORTB = 0;
	PORTC = 0;
	PORTD = 0;
	PORTE = 0;
	LATA = 0;
	LATB = 0;
	LATC = 0;
	LATD = 0;
	LATE = 0;
	port_lcd = 0;
	latch_lcd  =0;
	LED_LAT = 0; // LED off
	PORTD = 0;
	LATD = 0;	
    CTMUCONH = 0 ;
    CTMUCONL = 0 ;
	CCP1CON = 0;
    CCP2CON = 0;
    CCP3CON = 0;
    CCP4CON = 0;
    CCP5CON = 0;
	OSCCON =  0b01111100;
    OSCCON2 = 0b00011000;
	OSCTUNE = 0;
	PSPCON = 0;
	SSPCON1 = 0;
	SSPCON2 = 0;
	ODCON =0;
	PMD0 = 0b11111111;
    PMD1 = 0b11110000;
    PMD2 = 0b00001111;	
	CM1CON = 0;
	CM2CON = 0;
    RCSTA1 = 0;
    RCSTA2 = 0;
	SPBRGH2 = 0;
	SPBRGH1 = 0;
	SPBRG2 = 0;
	TXSTA1 = 0;
	TXSTA2 = 0;
	PIE1 = 0 ;
	PIE2 = 0 ;
	PIE3 = 0 ;
	PIE4 = 0 ;
	PIE5 = 0 ;
	CVRCON = 0;
	HLVDCON = 0;
	CANCON =  0b11100000;
	CANSTAT = 0b10000000;
	//0 prescaler 62,5 ms
	T1CON = 0b00000011;	
	T2CON = 0b00000100;	
	
    T3CON = 0b00110000;
	
}











void main(void)
{
	
	// unsigned char tab[10]="s89ab";
	/*unsigned char tab[10]="s.67-89ab";
	unsigned char tab2[10]="ekran lcd";*/
	//unsigned char tab3[2]=".";
	// unsigned char tab4[2]="z";
	// unsigned char tab5[2]="b";
	
	unsigned char  i2=0, i3=0, numer=0, a;
		
	deklaracje();
	
	Lcd_init(ustawienia_lcd);
	//tu jest - 2 bo dwie ostatnie opcje nie sa wczytywane z eeprom	
	for(i2=2; i2<(ilosc_linii-1); i2++ ){
		menu[i2].zmienna =  wczytaj_bajt_eeprom( i2+1, menu[i2].zmienna);	
	};
		
		
	sprawdz_przekroczenie(menu);
	numer = show_menu(numer,markers1);
	
	
	// check_busy();
	//i2 = 0x80+0x0b;	
	// send_dana(i2);
	
	// send_dana(linia_gorna+9);
	// check_busy();
	// write_lcd_string(tab3); 
	
	
	di();
	PR2 = czas_oczekiwania_480us;
	T2CON = t2con_dla_480us;
	PIR1bits.TMR2IF = 0;
	menu[numer_ds].zmienna = ds18_init(&Tris_ds1820, &Port_ds1820, pin_ds1820 ,  czas_oczekiwania_480us, t2con_dla_480us);
	if (menu[numer_ds].zmienna != 0){	
		ds_send_polecenie(&Tris_ds1820, &Port_ds1820, pin_ds1820, tab_pomiar);
	}
	
	InterruptsEnable();
	
	
	
	
	
	i=0;
	while (1) {
		//// Toggle LED
		// delay1ktcy(125); //500ms @ 1MHz
		
		
		//jesli przycisk wcisniety oraz brak przerwania TMR1IE
		//uruchom przerwanie TMR1IE
		if (KEY1_PORT == 0 && PIE1bits.TMR1IE == 0 && numer != 0 && numer != 1) {
		
			//taki jakby enter
			//zmiana wartosci liczby
			//uruchamiam przerwanie
			// TMR1H = 0 ;
			// TMR1L = 0 ;
			WRITETIMER1(0);
			PIE1bits.TMR1IE = 1;
			
			i = 1; 
			
			//xor z zawartoscia markers1  - do przelaczenia stanu
			//wszystkie pozostale bity nie ulegaja zmianie
			// xor robie z 1   czyli 00000001
			//jesli bit0 jest 0 wyjdzie 1
			//jesli bit0 jest 1 wyjdzie 0  
			markers1 = markers1 ^ czy_zmieniam_opcje ;
			//			odznaczam bit ze odswiezam liczby
			markers1 = markers1 & ~odswiez_liczby;
			numer = show_menu(numer,markers1);
			
			
			
		};
		
		//change gora dol opcji
		if ( (KEY2_PORT == 0 && PIE1bits.TMR1IE == 0) || (KEY2_PORT == 0 && ile_czasu_wcisnieto> 5 ) ) {
		
			
			//uruchamiam przerwanie
			WRITETIMER1(0);
			PIE1bits.TMR1IE = 1;
			
			i = 2; 
						
			//jesli zaznaczono zmiane opcji
			if  (markers1 & czy_zmieniam_opcje) {
				if (numer!= numer_zapisu){
					menu[numer].zmienna +=1;
					ile_czasu_wcisnieto =  0;
					sprawdz_przekroczenie(menu);
					
					//jesli tylko zmieniam opcje nie przechodze miedzy opcjami
					//to tylko kaze odswiezac wartosci
				
				}
				else{
					
					
					
					//zapis danych do eeprom
					
					INTCONbits.GIE = 0;
					EECON1bits.EEPGD = 0;					
					EECON1bits.CFGS=0;
					EECON1bits.WREN = 1;
					
					for(i2=1; i2<(ilosc_linii-1); i2++ ){
						zapisz_bajt_eeprom( i2+1, menu[i2].zmienna);
						
					
					};
					INTCONbits.GIE = 1;
					EECON1bits.WREN = 0;
				}
				markers1 = markers1 | odswiez_liczby;
			}
			//jesli przechodze miedzy opcjami menu
			else
			{				
				numer +=1; 
				markers1 = markers1 & ~odswiez_liczby;
				
			}
			
			numer = show_menu(numer, markers1);
		};
		
		
		
		
		
		
		
		//jesli co 1s odswiezam tylko wartosci
		if  (markers1 & spr_ds){
			//odznaczam
			INTCONbits.GIE = 0;
			INTCONbits.PEIE = 0;
			if (menu[numer_ds].zmienna != 0){
				//jesli jest dolaczony ds to odczytaj temperature
				//wylaczam przerwania
				
				menu[numer_ds].zmienna = ds18_init(&Tris_ds1820, &Port_ds1820, pin_ds1820, czas_oczekiwania_480us, t2con_dla_480us );
				if (menu[numer_ds].zmienna != 0){
					PR2 = czas_oczekiwania_60us;
					T2CON = t2con_dla_60us;
					PIR1bits.TMR2IF = 0;
					ds_send_polecenie(&Tris_ds1820, &Port_ds1820, pin_ds1820, tab_odczyt);
					ds_odbior( &Port_ds1820, pin_ds1820, jak_duzo_bajtow_odbieram, tab_ds);
					menu[11].zmienna = ds_crc_check(tab_ds);
					
					// ds_odbior( PORTDbits, RD3, jak_duzo_bajtow_odbieram, tab_ds);
				};
			};
			
			Nop();
			PR2 = czas_oczekiwania_480us;
			T2CON = t2con_dla_480us;
			PIR1bits.TMR2IF = 0;
			menu[numer_ds].zmienna = ds18_init(&Tris_ds1820, &Port_ds1820, pin_ds1820 , czas_oczekiwania_480us, t2con_dla_480us);
			if (menu[numer_ds].zmienna != 0)	
				PR2 = czas_oczekiwania_60us;
				T2CON = t2con_dla_60us;
				PIR1bits.TMR2IF = 0;
				ds_send_polecenie(&Tris_ds1820, &Port_ds1820, pin_ds1820, tab_pomiar);
			
			
			markers1 = markers1 & ~spr_ds;
			INTCONbits.GIE = 1;
			INTCONbits.PEIE = 1;
		};
		
		
		//jesli co 1s odswiezam tylko wartosci
		if  (markers1 & odswiez_liczby){
			//odznaczam
			
			numer = show_menu(numer, markers1);
			markers1 = markers1 & ~odswiez_liczby;
		}
		
		
	};
}
//dla xc8
void interrupt high(void) {
//dla sdcc
// void high(void) __interrupt 1 {
	
	if(INTCONbits.TMR0IF && INTCONbits.TMR0IE) {    // Timer0 overflow interrupt
		INTCONbits.TMR0IF = 0;    // ACK
		
		// LATDbits.LATD0 = !LATDbits.LATD0;
		LED_LAT = !LED_LAT; 
		// a_bit = a_bit;
		
		// LATCbits.LATC0 = a_bit;
		menu[sekundy].zmienna +=1;
		if (menu[sekundy].zmienna >= 60) {
			menu[minuty].zmienna +=1;
			menu[sekundy].zmienna = 0;
			
			if (menu[minuty].zmienna >= 60) {
				menu[minuty].zmienna = 0;
				menu[godziny].zmienna += 1;
				
				if (menu[godziny].zmienna >= 24) {
					menu[godziny].zmienna = 0;
					//menu[doby].zmienna += 1;
				};
			}; 
			
		};
		//xor - zaznaczam
		markers1 =  markers1 ^ odswiez_liczby ;
		markers1 =  markers1 ^ spr_ds ;
		
		
	};
	
	if (PIE1bits.TMR1IE && PIR1bits.TMR1IF ) {
		PIR1bits.TMR1IF = 0 ;
		if (KEY1_PORT == 1 && i==1)  {
			//wylaczam przerwanie jesli juz puscilem przycisk
			PIE1bits.TMR1IE = 0;
			i=0;
			ile_czasu_wcisnieto =0;
			
		}
		else if (KEY1_PORT == 0 && i==1){
			ile_czasu_wcisnieto +=1;
		
		}
		
		else if (KEY2_PORT == 1 && i==2)  {
			//wylaczam przerwanie jesli juz puscilem przycisk
			PIE1bits.TMR1IE = 0;
			i=0;
			ile_czasu_wcisnieto =0;
			
		}
		else if (KEY2_PORT == 0 && i==2){
			ile_czasu_wcisnieto +=1;
		
		}
		
	};
	
	
	// Nop();
	
}

void   sprawdz_opcje(unsigned int nr, unsigned int adres_linii){
	unsigned char _ii, bajt,*adres, dana;
	check_busy();
	send_dana(adres_linii + menu[nr].location);
	check_busy();	
	if (nr == numer_ds) {
		if (menu[nr].zmienna != 0)
			write_lcd_string(tab_ok);
		else{
			utoa(tab , menu[nr].zmienna,  10 );
			write_lcd_string(tab);
			check_busy();
			write_lcd(' ');
			check_busy();
			write_lcd(' ');
		};
		
	check_busy();
	send_dana(adres_linii + 10);
		if (menu[11].zmienna == tab_ds[8])
			write_lcd_string(tab_crc_ok);
		else{
			utoa(tab , menu[11].zmienna,  16 );
			write_lcd_string(tab);
			check_busy();
			write_lcd(' ');
			check_busy();
			write_lcd(' ');
			
			// utoa(tab , menu[11].zmienna,  16 );
		
		
		};
		
	}	
	else if (nr == 0 ) {
	
		wyswietl_czas();
	
	}
	else if (nr == numer_bajt){
		//wyswietla bajt
		unsigned char tab_bajt_ds[16];
		adres = tab_bajt_ds;
		for(_ii = 0; _ii < jak_duzo_bajtow_wyswietlam; _ii++){
			dana = tab_ds[_ii];
			bajt = ( dana >> 4) & 0x0f ;
			// utoa(adres, bajt, 16);
			if (bajt <=9)
				*adres = bajt + 0x30;
			else	
				*adres = bajt + 0x37;
			check_busy();
			write_lcd(*adres);	
			adres++; 
			dana = tab_ds[_ii];
			bajt = (0x0f & dana);
			if (bajt <=9)
				*adres = bajt + 0x30;
			else	
				*adres = bajt + 0x37;
			check_busy();
			write_lcd(*adres);	
			adres++; 
			// if bajt ==
			// tab_bajt_ds[_ii*2+1] = 0x30 + (0x0f & tab_ds[_ii]);  
			// tab_bajt_ds[_ii*2] = 0x30 +  
			//
			// adres++; 
			
			
		
		};
		adres--;
		*adres = 0;
		
		// for (_ii = 0; _ii<jak_duzo_bajtow_odbieram ; _ii++){
			// check_busy();
			// write_lcd(*adres);
			// adres++;
		
		// }
	
	}
	
	else if (nr == numer_bajt+1){
		//wyswietla bajt
		unsigned char tab_bajt_ds[16];
		adres = tab_bajt_ds;
		for(_ii = 7; _ii < jak_duzo_bajtow_odbieram; _ii++){
			dana = tab_ds[_ii];
			bajt = ( dana >> 4) & 0x0f ;
			// utoa(adres, bajt, 16);
			if (bajt <=9)
				*adres = bajt + 0x30;
			else	
				*adres = bajt + 0x37;
			check_busy();
			write_lcd(*adres);	
			adres++; 
			dana = tab_ds[_ii];
			bajt = (0x0f & dana);
			if (bajt <=9)
				*adres = bajt + 0x30;
			else	
				*adres = bajt + 0x37;
			check_busy();
			write_lcd(*adres);	
			adres++; 
			
		};	
		
		
		
		check_busy();
		write_lcd(' ');
		dana = menu[11].zmienna ;
		bajt = ( dana >> 4) & 0x0f ;
		// utoa(adres, bajt, 16);
		if (bajt <=9)
			bajt +=  0x30;
		else	
			bajt +=  0x37;
		check_busy();
		write_lcd(bajt);	
		adres++; 
		dana = menu[11].zmienna;
		bajt = (0x0f & dana);
		if (bajt <=9)
			bajt = bajt + 0x30;
		else	
			bajt = bajt + 0x37;
		check_busy();
		write_lcd(bajt);	
	}
	
	else if ( (nr == (numer_bajt+2)) || ( nr == 2) ) {
		//wyswietla bajt
		unsigned char ulamek, temp;
		float ulamek_f;
		 int status;
		 char buf[10];
		 // char *buf2;
		// for(_ii = 0; _ii < 2; _ii++){
		dana = tab_ds[0];
		ulamek = dana & 0x0f;
		dana = tab_ds[0];
		temp = dana >> 4;
		_ii = tab_ds[1] & 0x0f;
		_ii = _ii << 4;
		temp = temp + _ii; 
		
		// utoa(tab, temp, 10);
		// }
		// check_busy();
		// write_lcd_string(tab);
		// *adres = 0;
		// check_busy();
		// write_lcd(' ');
		// utoa(tab, ulamek, 10);
		// check_busy();
		// write_lcd_string(tab);
		// check_busy();
		// write_lcd(' ');
		ulamek_f = ulamek/16.0;
		ulamek_f = temp + ulamek_f;
		// buf = ftoa(ulamek_f, &status);
		sprintf(buf,"%6.3f %cC \0",ulamek_f,_stopni);
		check_busy();
		write_lcd_string(buf);
		// write_lcd_string(tab_bajt_ds);
		
		
		// write_lcd_string(tab_ds);
	}	
	else if (nr == 10 ){
	
		utoa(tab, menu[nr].zmienna,  10 );
		
		clear_couple_places(5);
		check_busy();
		send_dana(adres_linii + menu[nr].location);
		
		
		write_lcd_string(tab);
		check_busy();
		write_lcd(' ');
		check_busy();
		write_lcd(menu[nr].zmienna);
		check_busy();
		sprintf( tab, "%c",menu[nr].zmienna);
		write_lcd_string(tab);
		
	}
	else {
		//pozostale nie powyzsze
		//zamiana liczby na ciag znakow ascii
		utoa(tab, menu[nr].zmienna,  10 );
		
		clear_couple_places(5);
		check_busy();
		send_dana(adres_linii + menu[nr].location);
		
		
		write_lcd_string(tab);
		
	};
	


}


// unsigned int show_menu(unsigned int nr, znaczniki_var znacznik ){
unsigned int show_menu(unsigned int nr , unsigned int markers1){
	unsigned int i2,i3;
	// unsigned char *tab;
	
	if ((markers1 & odswiez_liczby) == 0) {
	
		check_busy();
		send_dana(display_clear);	
		check_busy();
	}
	
	
	
	
	if (nr == (ilosc_linii) ) { nr = 0; };
	//sprawdzenie stanu bitu
	if  (markers1 & czy_zmieniam_opcje) {
		//i2=8;
		
		i2 =  menu[nr].location-1;
		i3=0;
		
	}	
	else {
		i2 = 0;
		i3=1;
		
		//jesli na poczatku linii
		//gwiazdka
		
	};
	
	
	
	
	//check_busy();
	
	if ((markers1 & odswiez_liczby) == 0) {
		send_dana(linia_gorna+i3);
		check_busy();
		write_lcd_string(menu[nr].linia);
		check_busy();
		
		send_dana(linia_gorna+i2);
		check_busy();
		write_lcd('*');
		check_busy();
		
	}
	
	
	
	
	
	
	
	
	// send_dana(' ');
	// 
	//write_lcd(menu[nr].zmienna+0x30);/**/
	
	
	// if (nr== numer_godzin ) {
		
		
		// if (menu[nr].zmienna >= 24) {
			// menu[nr].zmienna = 0;
			
		// };
		
	// };
	
	// if (nr== numer_minut ) {
		
		
		// if (menu[nr].zmienna >= 60) {
			// menu[nr].zmienna = 0;
			
		// };
		
	// };
	
	//ta linia wyswietla opcje na gornej linii
	sprawdz_opcje(nr,linia_gorna);
	
	
	
	//wyswietlanie linii dolnej
	check_busy();
	send_dana(linia_dolna);
	check_busy();
	
	//jesli odswiezam menu
	if ((markers1 & odswiez_liczby) == 0) {
		if (nr == (ilosc_linii-1)){
	// if (nr == 4){
		// nr = 0;
			
			write_lcd_string(menu[0].linia);
			
			
		}
		else
		{
		
			write_lcd_string(menu[nr+1].linia);
			
		
		
		}
		
		
	}
	check_busy();
	//na dolnej wyswietlam linie pierwszego menu
	if (nr == (ilosc_linii-1)){
	// if (nr == 4){
		// nr = 0;
		
		send_dana(linia_dolna+menu[0].location);
		
		// uitoa(menu[0].zmienna, tab, 10 );
		wyswietl_czas();
		
	}
	else{	
		
		
		/*send_dana(linia_dolna+menu[nr+1].location);
		
		clear_couple_places(5);
		check_busy();
		send_dana(linia_dolna+menu[nr+1].location);
		
		uitoa(menu[nr+1].zmienna, tab, 10 );
		write_lcd_string(tab);
		*/
		 // return nr;
		sprawdz_opcje(nr+1,linia_dolna); 
		
	};
	
	
	
	
	return nr;
	
	
}



void wyswietl_czas(void){
	
	
	//funkcja zamienia liczbe calkowita na
	//
	utoa( tab, menu[godziny].zmienna, 10 );
	if (menu[godziny].zmienna < 10 ) {
		check_busy();
		write_lcd(' ');
		
	}
	write_lcd_string(tab);	
	check_busy();	
	write_lcd(':');
	check_busy();
	
	utoa( tab, menu[minuty].zmienna,10 );
	if (menu[minuty].zmienna < 10 ) {
		
		write_lcd('0');
		
	}
	write_lcd_string(tab);
	check_busy();
	write_lcd(':');
	check_busy();
	
	utoa( tab, menu[sekundy].zmienna,10 );
	if (menu[sekundy].zmienna < 10 ) {
		
		write_lcd('0');
		
		
	}
	write_lcd_string(tab);
	
}

void sprawdz_przekroczenie(struct linie_menu mm[]){
	if  (mm[numer_godzin].zmienna>=24) 
		mm[numer_godzin].zmienna = 0;
		
	if (mm[numer_minut].zmienna>=60) 
		mm[numer_minut].zmienna = 0;
	if (mm[sekundy].zmienna>=60) 
		mm[sekundy].zmienna = 0;	
	if (mm[numer_zapisu].zmienna>0) 
		mm[numer_zapisu].zmienna = 0;	
}